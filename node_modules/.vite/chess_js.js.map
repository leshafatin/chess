{
  "version": 3,
  "sources": ["../chess.js/chess.js", "dep:chess_js"],
  "sourcesContent": ["/*\n * Copyright (c) 2021, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nvar Chess = function (fen) {\n  var BLACK = 'b'\n  var WHITE = 'w'\n\n  var EMPTY = -1\n\n  var PAWN = 'p'\n  var KNIGHT = 'n'\n  var BISHOP = 'b'\n  var ROOK = 'r'\n  var QUEEN = 'q'\n  var KING = 'k'\n\n  var SYMBOLS = 'pnbrqkPNBRQK'\n\n  var DEFAULT_POSITION =\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']\n\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n  }\n\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n  }\n\n  // prettier-ignore\n  var ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n  ];\n\n  // prettier-ignore\n  var RAYS = [\n     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n  ];\n\n  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\n\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n  }\n\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n  }\n\n  var RANK_1 = 7\n  var RANK_2 = 6\n  var RANK_3 = 5\n  var RANK_4 = 4\n  var RANK_5 = 3\n  var RANK_6 = 2\n  var RANK_7 = 1\n  var RANK_8 = 0\n\n  // prettier-ignore\n  var SQUARES = {\n    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n  };\n\n  var ROOKS = {\n    w: [\n      { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n      { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n  }\n\n  var board = new Array(128)\n  var kings = { w: EMPTY, b: EMPTY }\n  var turn = WHITE\n  var castling = { w: 0, b: 0 }\n  var ep_square = EMPTY\n  var half_moves = 0\n  var move_number = 1\n  var history = []\n  var header = {}\n  var comments = {}\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION)\n  } else {\n    load(fen)\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    board = new Array(128)\n    kings = { w: EMPTY, b: EMPTY }\n    turn = WHITE\n    castling = { w: 0, b: 0 }\n    ep_square = EMPTY\n    half_moves = 0\n    move_number = 1\n    history = []\n    if (!keep_headers) header = {}\n    comments = {}\n    update_setup(generate_fen())\n  }\n\n  function prune_comments() {\n    var reversed_history = []\n    var current_comments = {}\n    var copy_comment = function (fen) {\n      if (fen in comments) {\n        current_comments[fen] = comments[fen]\n      }\n    }\n    while (history.length > 0) {\n      reversed_history.push(undo_move())\n    }\n    copy_comment(generate_fen())\n    while (reversed_history.length > 0) {\n      make_move(reversed_history.pop())\n      copy_comment(generate_fen())\n    }\n    comments = current_comments\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION)\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    var tokens = fen.split(/\\s+/)\n    var position = tokens[0]\n    var square = 0\n\n    if (!validate_fen(fen).valid) {\n      return false\n    }\n\n    clear(keep_headers)\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\n        square++\n      }\n    }\n\n    turn = tokens[1]\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\n    half_moves = parseInt(tokens[4], 10)\n    move_number = parseInt(tokens[5], 10)\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square',\n    }\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/)\n    if (tokens.length !== 6) {\n      return { valid: false, error_number: 1, error: errors[1] }\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return { valid: false, error_number: 2, error: errors[2] }\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return { valid: false, error_number: 3, error: errors[3] }\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return { valid: false, error_number: 4, error: errors[4] }\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return { valid: false, error_number: 5, error: errors[5] }\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return { valid: false, error_number: 6, error: errors[6] }\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/')\n    if (rows.length !== 8) {\n      return { valid: false, error_number: 7, error: errors[7] }\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0\n      var previous_was_number = false\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return { valid: false, error_number: 8, error: errors[8] }\n          }\n          sum_fields += parseInt(rows[i][k], 10)\n          previous_was_number = true\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return { valid: false, error_number: 9, error: errors[9] }\n          }\n          sum_fields += 1\n          previous_was_number = false\n        }\n      }\n      if (sum_fields !== 8) {\n        return { valid: false, error_number: 10, error: errors[10] }\n      }\n    }\n\n    if (\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\n      (tokens[3][1] == '6' && tokens[1] == 'b')\n    ) {\n      return { valid: false, error_number: 11, error: errors[11] }\n    }\n\n    /* everything's okay! */\n    return { valid: true, error_number: 0, error: errors[0] }\n  }\n\n  function generate_fen() {\n    var empty = 0\n    var fen = ''\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++\n      } else {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        var color = board[i].color\n        var piece = board[i].type\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    var cflags = ''\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K'\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q'\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k'\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q'\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-'\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1]\n      }\n    }\n    return header\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1'\n      header['FEN'] = fen\n    } else {\n      delete header['SetUp']\n      delete header['FEN']\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]]\n    return piece ? { type: piece.type, color: piece.color } : null\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false\n    }\n\n    var sq = SQUARES[square]\n\n    /* don't let the user place more than one king */\n    if (\n      piece.type == KING &&\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n    ) {\n      return false\n    }\n\n    board[sq] = { type: piece.type, color: piece.color }\n    if (piece.type === KING) {\n      kings[piece.color] = sq\n    }\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  function remove(square) {\n    var piece = get(square)\n    board[SQUARES[square]] = null\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY\n    }\n\n    update_setup(generate_fen())\n\n    return piece\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type,\n    }\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION\n      move.promotion = promotion\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN\n    }\n    return move\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (\n        board[from].type === PAWN &&\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\n      ) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]))\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags))\n      }\n    }\n\n    var moves = []\n    var us = turn\n    var them = swap_color(us)\n    var second_rank = { b: RANK_7, w: RANK_2 }\n\n    var first_sq = SQUARES.a8\n    var last_sq = SQUARES.h1\n    var single_square = false\n\n    /* do we want legal moves? */\n    var legal =\n      typeof options !== 'undefined' && 'legal' in options\n        ? options.legal\n        : true\n\n    var piece_type =\n      typeof options !== 'undefined' &&\n      'piece' in options &&\n      typeof options.piece === 'string'\n        ? options.piece.toLowerCase()\n        : true\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square]\n        single_square = true\n      } else {\n        /* invalid square */\n        return []\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece == null || piece.color !== us) {\n        continue\n      }\n\n      if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0]\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL)\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1]\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j]\n          if (square & 0x88) continue\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE)\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n          }\n        }\n      } else if (piece_type === true || piece_type === piece.type) {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j]\n          var square = i\n\n          while (true) {\n            square += offset\n            if (square & 0x88) break\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL)\n            } else {\n              if (board[square].color === us) break\n              add_move(board, moves, i, square, BITS.CAPTURE)\n              break\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (piece_type === true || piece_type === KING) {\n      if (!single_square || last_sq === kings[us]) {\n        /* king-side castling */\n        if (castling[us] & BITS.KSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from + 2\n\n          if (\n            board[castling_from + 1] == null &&\n            board[castling_to] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from + 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n          }\n        }\n\n        /* queen-side castling */\n        if (castling[us] & BITS.QSIDE_CASTLE) {\n          var castling_from = kings[us]\n          var castling_to = castling_from - 2\n\n          if (\n            board[castling_from - 1] == null &&\n            board[castling_from - 2] == null &&\n            board[castling_from - 3] == null &&\n            !attacked(them, kings[us]) &&\n            !attacked(them, castling_from - 1) &&\n            !attacked(them, castling_to)\n          ) {\n            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n          }\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = []\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i])\n      }\n      undo_move()\n    }\n\n    return legal_moves\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, moves) {\n    var output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        var disambiguator = get_disambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    make_move(move)\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    undo_move()\n\n    return output\n  }\n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue\n\n      var piece = board[i]\n      var difference = i - square\n      var index = difference + 119\n\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        var offset = RAYS[index]\n        var j = i + offset\n\n        var blocked = false\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color])\n  }\n\n  function in_check() {\n    return king_attacked(turn)\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0\n  }\n\n  function insufficient_material() {\n    var pieces = {}\n    var bishops = []\n    var num_pieces = 0\n    var sq_color = 0\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color)\n        }\n        num_pieces++\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true\n    } else if (\n      /* k vs. kn .... or .... k vs. kb */\n      num_pieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0\n      var len = bishops.length\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = []\n    var positions = {}\n    var repetition = false\n\n    while (true) {\n      var move = undo_move()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen().split(' ').slice(0, 4).join(' ')\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      if (!moves.length) {\n        break\n      }\n      make_move(moves.pop())\n    }\n\n    return repetition\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: { b: kings.b, w: kings.w },\n      turn: turn,\n      castling: { b: castling.b, w: castling.w },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number,\n    })\n  }\n\n  function make_move(move) {\n    var us = turn\n    var them = swap_color(us)\n    push(move)\n\n    board[move.to] = board[move.from]\n    board[move.from] = null\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null\n      } else {\n        board[move.to + 16] = null\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = { type: move.promotion, color: us }\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1\n        var castling_from = move.to + 1\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1\n        var castling_from = move.to - 2\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      }\n\n      /* turn off castling */\n      castling[us] = ''\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          castling[us] & ROOKS[us][i].flag\n        ) {\n          castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          castling[them] & ROOKS[them][i].flag\n        ) {\n          castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16\n      } else {\n        ep_square = move.to + 16\n      }\n    } else {\n      ep_square = EMPTY\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0\n    } else {\n      half_moves++\n    }\n\n    if (turn === BLACK) {\n      move_number++\n    }\n    turn = swap_color(turn)\n  }\n\n  function undo_move() {\n    var old = history.pop()\n    if (old == null) {\n      return null\n    }\n\n    var move = old.move\n    kings = old.kings\n    turn = old.turn\n    castling = old.castling\n    ep_square = old.ep_square\n    half_moves = old.half_moves\n    move_number = old.move_number\n\n    var us = turn\n    var them = swap_color(turn)\n\n    board[move.from] = board[move.to]\n    board[move.from].type = move.piece // to undo any promotions\n    board[move.to] = null\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = { type: move.captured, color: them }\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index\n      if (us === BLACK) {\n        index = move.to - 16\n      } else {\n        index = move.to + 16\n      }\n      board[index] = { type: PAWN, color: them }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1\n        castling_from = move.to - 1\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2\n        castling_from = move.to + 1\n      }\n\n      board[castling_to] = board[castling_from]\n      board[castling_from] = null\n    }\n\n    return move\n  }\n\n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, moves) {\n    var from = move.from\n    var to = move.to\n    var piece = move.piece\n\n    var ambiguities = 0\n    var same_rank = 0\n    var same_file = 0\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from\n      var ambig_to = moves[i].to\n      var ambig_piece = moves[i].piece\n\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from)\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1)\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0)\n      }\n    }\n\n    return ''\n  }\n\n  function infer_piece_type(san) {\n    var piece_type = san.charAt(0)\n    if (piece_type >= 'a' && piece_type <= 'h') {\n      var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n      if (matches) {\n        return undefined\n      }\n      return PAWN\n    }\n    piece_type = piece_type.toLowerCase()\n    if (piece_type === 'o') {\n      return KING\n    }\n    return piece_type\n  }\n  function ascii() {\n    var s = '   +------------------------+\\n'\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . '\n      } else {\n        var piece = board[i].type\n        var color = board[i].color\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h\\n'\n\n    return s\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move)\n\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(\n        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n      if (matches) {\n        var piece = matches[1]\n        var from = matches[2]\n        var to = matches[3]\n        var promotion = matches[4]\n      }\n    }\n    var piece_type = infer_piece_type(clean_move)\n    var moves = null\n    var legalMoves = generate_moves({\n      legal: true,\n      piece: piece ? piece : piece_type,\n    })\n    moves = legalMoves\n    if (sloppy) {\n      var illegalMoves = generate_moves({\n        legal: false,\n        piece: piece ? piece : piece_type,\n      })\n      moves = illegalMoves\n    }\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (\n        clean_move === stripped_san(move_to_san(moves[i], legalMoves)) ||\n        (sloppy &&\n          clean_move === stripped_san(move_to_san(moves[i], illegalMoves)))\n      ) {\n        return moves[i]\n      } else {\n        if (\n          matches &&\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          SQUARES[from] == moves[i].from &&\n          SQUARES[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4\n  }\n\n  function file(i) {\n    return i & 15\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n      r = rank(i)\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move)\n    move.san = move_to_san(move, generate_moves({ legal: true }))\n    move.to = algebraic(move.to)\n    move.from = algebraic(move.from)\n\n    var flags = ''\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag]\n      }\n    }\n    move.flags = flags\n\n    return move\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {}\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property])\n      } else {\n        dupe[property] = obj[property]\n      }\n    }\n\n    return dupe\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '')\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({ legal: false })\n    var nodes = 0\n    var color = turn\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1)\n          nodes += child_nodes\n        } else {\n          nodes++\n        }\n      }\n      undo_move()\n    }\n\n    return nodes\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: (function () {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = []\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7\n          continue\n        }\n        keys.push(algebraic(i))\n      }\n      return keys\n    })(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function (fen) {\n      return load(fen)\n    },\n\n    reset: function () {\n      return reset()\n    },\n\n    moves: function (options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options)\n      var moves = []\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (\n          typeof options !== 'undefined' &&\n          'verbose' in options &&\n          options.verbose\n        ) {\n          moves.push(make_pretty(ugly_moves[i]))\n        } else {\n          moves.push(\n            move_to_san(ugly_moves[i], generate_moves({ legal: true }))\n          )\n        }\n      }\n\n      return moves\n    },\n\n    in_check: function () {\n      return in_check()\n    },\n\n    in_checkmate: function () {\n      return in_checkmate()\n    },\n\n    in_stalemate: function () {\n      return in_stalemate()\n    },\n\n    in_draw: function () {\n      return (\n        half_moves >= 100 ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    insufficient_material: function () {\n      return insufficient_material()\n    },\n\n    in_threefold_repetition: function () {\n      return in_threefold_repetition()\n    },\n\n    game_over: function () {\n      return (\n        half_moves >= 100 ||\n        in_checkmate() ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    validate_fen: function (fen) {\n      return validate_fen(fen)\n    },\n\n    fen: function () {\n      return generate_fen()\n    },\n\n    board: function () {\n      var output = [],\n        row = []\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({ type: board[i].type, color: board[i].color })\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row)\n          row = []\n          i += 8\n        }\n      }\n\n      return output\n    },\n\n    pgn: function (options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\n'\n      var max_width =\n        typeof options === 'object' && typeof options.max_width === 'number'\n          ? options.max_width\n          : 0\n      var result = []\n      var header_exists = false\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n        header_exists = true\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline)\n      }\n\n      var append_comment = function (move_string) {\n        var comment = comments[generate_fen()]\n        if (typeof comment !== 'undefined') {\n          var delimiter = move_string.length > 0 ? ' ' : ''\n          move_string = `${move_string}${delimiter}{${comment}}`\n        }\n        return move_string\n      }\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = []\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      var moves = []\n      var move_string = ''\n\n      /* special case of a commented starting position with no moves */\n      if (reversed_history.length === 0) {\n        moves.push(append_comment(''))\n      }\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        move_string = append_comment(move_string)\n        var move = reversed_history.pop()\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...'\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string)\n          }\n          move_string = move_number + '.'\n        }\n\n        move_string =\n          move_string +\n          ' ' +\n          move_to_san(move, generate_moves({ legal: false }))\n        make_move(move)\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(append_comment(move_string))\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result)\n      }\n\n      /* history should be back to what it was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ')\n      }\n\n      var strip = function () {\n        if (result.length > 0 && result[result.length - 1] === ' ') {\n          result.pop()\n          return true\n        }\n        return false\n      }\n\n      /* NB: this does not preserve comment whitespace. */\n      var wrap_comment = function (width, move) {\n        for (var token of move.split(' ')) {\n          if (!token) {\n            continue\n          }\n          if (width + token.length > max_width) {\n            while (strip()) {\n              width--\n            }\n            result.push(newline)\n            width = 0\n          }\n          result.push(token)\n          width += token.length\n          result.push(' ')\n          width++\n        }\n        if (strip()) {\n          width--\n        }\n        return width\n      }\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0\n      for (var i = 0; i < moves.length; i++) {\n        if (current_width + moves[i].length > max_width) {\n          if (moves[i].includes('{')) {\n            current_width = wrap_comment(current_width, moves[i])\n            continue\n          }\n        }\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop()\n          }\n\n          result.push(newline)\n          current_width = 0\n        } else if (i !== 0) {\n          result.push(' ')\n          current_width++\n        }\n        result.push(moves[i])\n        current_width += moves[i].length\n      }\n\n      return result.join('')\n    },\n\n    load_pgn: function (pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\')\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true\n        }\n        return false\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char =\n          typeof options === 'object' &&\n          typeof options.newline_char === 'string'\n            ? options.newline_char\n            : '\\r?\\n'\n        var header_obj = {}\n        var headers = header.split(new RegExp(mask(newline_char)))\n        var key = ''\n        var value = ''\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\ *\\]$/, '$1')\n          if (trim(key).length > 0) {\n            header_obj[key] = value\n          }\n        }\n\n        return header_obj\n      }\n\n      var newline_char =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\r?\\n'\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp(\n        '^(\\\\[((?:' +\n          mask(newline_char) +\n          ')|.)*\\\\])' +\n          '(?:' +\n          mask(newline_char) +\n          '){2}'\n      )\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn)\n        ? header_regex.exec(pgn)[1]\n        : ''\n\n      // Put the board in the starting position\n      reset()\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options)\n      for (var key in headers) {\n        set_header([key, headers[key]])\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false\n        }\n      }\n\n      /* NB: the regexes below that delete move numbers, recursive\n       * annotations, and numeric annotation glyphs may also match\n       * text in comments. To prevent this, we transform comments\n       * by hex-encoding them in place and decoding them again after\n       * the other tokens have been deleted.\n       *\n       * While the spec states that PGN files should be ASCII encoded,\n       * we use {en,de}codeURIComponent here to support arbitrary UTF8\n       * as a convenience for modern users */\n\n      var to_hex = function (string) {\n        return Array.from(string)\n          .map(function (c) {\n            /* encodeURI doesn't transform most ASCII characters,\n             * so we handle these ourselves */\n            return c.charCodeAt(0) < 128\n              ? c.charCodeAt(0).toString(16)\n              : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\n          })\n          .join('')\n      }\n\n      var from_hex = function (string) {\n        return string.length == 0\n          ? ''\n          : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\n      }\n\n      var encode_comment = function (string) {\n        string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\n        return `{${to_hex(string.slice(1, string.length - 1))}}`\n      }\n\n      var decode_comment = function (string) {\n        if (string.startsWith('{') && string.endsWith('}')) {\n          return from_hex(string.slice(1, string.length - 1))\n        }\n      }\n\n      /* delete header to get the moves */\n      var ms = pgn\n        .replace(header_string, '')\n        .replace(\n          /* encode comments so they don't get deleted below */\n          new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\n          function (match, bracket, semicolon) {\n            return bracket !== undefined\n              ? encode_comment(bracket)\n              : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\n          }\n        )\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '')\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '')\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '')\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/))\n\n      /* delete empty entries */\n      moves = moves.join(',').replace(/,,+/g, ',').split(',')\n      var move = ''\n\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        var comment = decode_comment(moves[half_move])\n        if (comment !== undefined) {\n          comments[generate_fen()] = comment\n          continue\n        }\n        move = move_from_san(moves[half_move], sloppy)\n\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n\n      comment = decode_comment(moves[moves.length - 1])\n      if (comment !== undefined) {\n        comments[generate_fen()] = comment\n        moves.pop()\n      }\n\n      /* examine last move */\n      move = moves[moves.length - 1]\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move])\n        }\n      } else {\n        move = move_from_san(move, sloppy)\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n      return true\n    },\n\n    header: function () {\n      return set_header(arguments)\n    },\n\n    ascii: function () {\n      return ascii()\n    },\n\n    turn: function () {\n      return turn\n    },\n\n    move: function (move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      var move_obj = null\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy)\n      } else if (typeof move === 'object') {\n        var moves = generate_moves()\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (\n            move.from === algebraic(moves[i].from) &&\n            move.to === algebraic(moves[i].to) &&\n            (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)\n          ) {\n            move_obj = moves[i]\n            break\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj)\n\n      make_move(move_obj)\n\n      return pretty_move\n    },\n\n    undo: function () {\n      var move = undo_move()\n      return move ? make_pretty(move) : null\n    },\n\n    clear: function () {\n      return clear()\n    },\n\n    put: function (piece, square) {\n      return put(piece, square)\n    },\n\n    get: function (square) {\n      return get(square)\n    },\n\n    remove: function (square) {\n      return remove(square)\n    },\n\n    perft: function (depth) {\n      return perft(depth)\n    },\n\n    square_color: function (square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square]\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n      }\n\n      return null\n    },\n\n    history: function (options) {\n      var reversed_history = []\n      var move_history = []\n      var verbose =\n        typeof options !== 'undefined' &&\n        'verbose' in options &&\n        options.verbose\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n        if (verbose) {\n          move_history.push(make_pretty(move))\n        } else {\n          move_history.push(move_to_san(move, generate_moves({ legal: true })))\n        }\n        make_move(move)\n      }\n\n      return move_history\n    },\n\n    get_comment: function () {\n      return comments[generate_fen()]\n    },\n\n    set_comment: function (comment) {\n      comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\n    },\n\n    delete_comment: function () {\n      var comment = comments[generate_fen()]\n      delete comments[generate_fen()]\n      return comment\n    },\n\n    get_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        return { fen: fen, comment: comments[fen] }\n      })\n    },\n\n    delete_comments: function () {\n      prune_comments()\n      return Object.keys(comments).map(function (fen) {\n        var comment = comments[fen]\n        delete comments[fen]\n        return { fen: fen, comment: comment }\n      })\n    },\n  }\n}\n\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (typeof exports !== 'undefined') exports.Chess = Chess\n/* export Chess object for any RequireJS compatible environment */\nif (typeof define !== 'undefined')\n  define(function () {\n    return Chess\n  })\n", "export default require(\"./node_modules/chess.js/chess.js\");"],
  "mappings": ";;;;;AAAA;AAAA;AA2BA,QAAI,QAAQ,SAAU,KAAK;AACzB,UAAI,QAAQ;AACZ,UAAI,QAAQ;AAEZ,UAAI,QAAQ;AAEZ,UAAI,OAAO;AACX,UAAI,SAAS;AACb,UAAI,SAAS;AACb,UAAI,OAAO;AACX,UAAI,QAAQ;AACZ,UAAI,OAAO;AAEX,UAAI,UAAU;AAEd,UAAI,mBACF;AAEF,UAAI,mBAAmB,CAAC,OAAO,OAAO,WAAW;AAEjD,UAAI,eAAe;AAAA,QACjB,GAAG,CAAC,IAAI,IAAI,IAAI;AAAA,QAChB,GAAG,CAAC,KAAK,KAAK,KAAK;AAAA;AAGrB,UAAI,gBAAgB;AAAA,QAClB,GAAG,CAAC,KAAK,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI;AAAA,QACpC,GAAG,CAAC,KAAK,KAAK,IAAI;AAAA,QAClB,GAAG,CAAC,KAAK,GAAG,IAAI;AAAA,QAChB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI;AAAA,QAClC,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI;AAAA;AAIpC,UAAI,UAAU;AAAA,QACZ;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAC/C;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAChD;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAC/C;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA,QAAI;AAAA,QAAG;AAAA,QAChD;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAE;AAAA;AAI9C,UAAI,OAAO;AAAA,QACR;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAC3D;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAE;AAAA,QAAI;AAAA,QAAI;AAAA,QAAM;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAE;AAAA,QAAM;AAAA,QAAE;AAAA,QAAM;AAAA,QAAE;AAAA,QAAM;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAC3D;AAAA,QAAI;AAAA,QAAI;AAAA,QAAI;AAAA,QAAE;AAAA,QAAM;AAAA,QAAI;AAAA,QAAE;AAAA,QAAM;AAAA,QAAI;AAAA,QAAE;AAAA,QAAM;AAAA,QAAI;AAAA,QAAI;AAAA,QAA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",
  "names": []
}
